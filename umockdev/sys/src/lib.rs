// Generated by gir (https://github.com/gtk-rs/gir @ 5327f5be4615)
// from .. (@ ???)
// from ../gir-files (@ 62da9eb7c4bd)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use glib_sys as glib;
use gobject_sys as gobject;

#[allow(unused_imports)]
use std::ffi::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong, c_void};
#[allow(unused_imports)]
use libc::{size_t, ssize_t, time_t, off_t, intptr_t, uintptr_t, FILE};
#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type UMockdevError = c_int;
pub const UMOCKDEV_ERROR_PARSE: UMockdevError = 0;
pub const UMOCKDEV_ERROR_VALUE: UMockdevError = 1;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UMockdevIoctlBaseClass {
    pub parent_class: gobject::GObjectClass,
    pub handle_ioctl: Option<unsafe extern "C" fn(*mut UMockdevIoctlBase, *mut UMockdevIoctlClient) -> gboolean>,
    pub handle_read: Option<unsafe extern "C" fn(*mut UMockdevIoctlBase, *mut UMockdevIoctlClient) -> gboolean>,
    pub handle_write: Option<unsafe extern "C" fn(*mut UMockdevIoctlBase, *mut UMockdevIoctlClient) -> gboolean>,
    pub client_connected: Option<unsafe extern "C" fn(*mut UMockdevIoctlBase, *mut UMockdevIoctlClient)>,
    pub client_vanished: Option<unsafe extern "C" fn(*mut UMockdevIoctlBase, *mut UMockdevIoctlClient)>,
}

impl ::std::fmt::Debug for UMockdevIoctlBaseClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UMockdevIoctlBaseClass @ {self:p}"))
         .field("handle_ioctl", &self.handle_ioctl)
         .field("handle_read", &self.handle_read)
         .field("handle_write", &self.handle_write)
         .field("client_connected", &self.client_connected)
         .field("client_vanished", &self.client_vanished)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _UMockdevIoctlBasePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UMockdevIoctlBasePrivate = _UMockdevIoctlBasePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UMockdevIoctlClientClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for UMockdevIoctlClientClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UMockdevIoctlClientClass @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _UMockdevIoctlClientPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UMockdevIoctlClientPrivate = _UMockdevIoctlClientPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UMockdevIoctlDataClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for UMockdevIoctlDataClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UMockdevIoctlDataClass @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _UMockdevIoctlDataPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UMockdevIoctlDataPrivate = _UMockdevIoctlDataPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UMockdevTestbedClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for UMockdevTestbedClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UMockdevTestbedClass @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _UMockdevTestbedPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type UMockdevTestbedPrivate = _UMockdevTestbedPrivate;

// Classes
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UMockdevIoctlBase {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut UMockdevIoctlBasePrivate,
}

impl ::std::fmt::Debug for UMockdevIoctlBase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UMockdevIoctlBase @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UMockdevIoctlClient {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut UMockdevIoctlClientPrivate,
}

impl ::std::fmt::Debug for UMockdevIoctlClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UMockdevIoctlClient @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UMockdevIoctlData {
    pub parent_instance: gobject::GObject,
    pub data: *mut u8,
    pub data_length1: c_int,
    pub client_addr: c_ulong,
    pub priv_: *mut UMockdevIoctlDataPrivate,
}

impl ::std::fmt::Debug for UMockdevIoctlData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UMockdevIoctlData @ {self:p}"))
         .field("data", &self.data)
         .field("data_length1", &self.data_length1)
         .field("client_addr", &self.client_addr)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct UMockdevTestbed {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut UMockdevTestbedPrivate,
}

impl ::std::fmt::Debug for UMockdevTestbed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("UMockdevTestbed @ {self:p}"))
         .finish()
    }
}

extern "C" {

    //=========================================================================
    // UMockdevError
    //=========================================================================
    pub fn umockdev_error_get_type() -> GType;

    //=========================================================================
    // UMockdevIoctlBase
    //=========================================================================
    pub fn umockdev_ioctl_base_get_type() -> GType;
    pub fn umockdev_ioctl_base_handle_ioctl(self_: *mut UMockdevIoctlBase, client: *mut UMockdevIoctlClient) -> gboolean;
    pub fn umockdev_ioctl_base_handle_read(self_: *mut UMockdevIoctlBase, client: *mut UMockdevIoctlClient) -> gboolean;
    pub fn umockdev_ioctl_base_handle_write(self_: *mut UMockdevIoctlBase, client: *mut UMockdevIoctlClient) -> gboolean;
    pub fn umockdev_ioctl_base_new() -> *mut UMockdevIoctlBase;

    //=========================================================================
    // UMockdevIoctlClient
    //=========================================================================
    pub fn umockdev_ioctl_client_get_type() -> GType;
    pub fn umockdev_ioctl_client_get_devnode(self_: *mut UMockdevIoctlClient) -> *const c_char;
    pub fn umockdev_ioctl_client_get_request(self_: *mut UMockdevIoctlClient) -> c_ulong;
    pub fn umockdev_ioctl_client_get_arg(self_: *mut UMockdevIoctlClient) -> *mut UMockdevIoctlData;
    pub fn umockdev_ioctl_client_get_connected(self_: *mut UMockdevIoctlClient) -> gboolean;
    pub fn umockdev_ioctl_client_execute(self_: *mut UMockdevIoctlClient, errno_: *mut c_int, error: *mut *mut glib::GError) -> c_int;
    pub fn umockdev_ioctl_client_complete(self_: *mut UMockdevIoctlClient, res: c_long, errno_: c_int);
    pub fn umockdev_ioctl_client_abort(self_: *mut UMockdevIoctlClient);

    //=========================================================================
    // UMockdevIoctlData
    //=========================================================================
    pub fn umockdev_ioctl_data_get_type() -> GType;
    pub fn umockdev_ioctl_data_ref(self_: *mut UMockdevIoctlData) -> *mut UMockdevIoctlData;
    pub fn umockdev_ioctl_data_unref(self_: *mut UMockdevIoctlData);
    pub fn umockdev_ioctl_data_resolve(self_: *mut UMockdevIoctlData, offset: size_t, len: size_t, error: *mut *mut glib::GError) -> *mut UMockdevIoctlData;
    pub fn umockdev_ioctl_data_set_ptr(self_: *mut UMockdevIoctlData, offset: size_t, child: *mut UMockdevIoctlData) -> gboolean;
    pub fn umockdev_ioctl_data_reload(self_: *mut UMockdevIoctlData, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_ioctl_data_update(self_: *mut UMockdevIoctlData, offset: size_t, new_data: *mut u8, new_data_length1: c_int);
    pub fn umockdev_ioctl_data_retrieve(self_: *mut UMockdevIoctlData, read_data: *mut *mut u8, read_data_length1: *mut c_int);

    //=========================================================================
    // UMockdevTestbed
    //=========================================================================
    pub fn umockdev_testbed_get_type() -> GType;
    pub fn umockdev_testbed_new() -> *mut UMockdevTestbed;
    pub fn umockdev_testbed_get_root_dir(self_: *mut UMockdevTestbed) -> *mut c_char;
    pub fn umockdev_testbed_get_sys_dir(self_: *mut UMockdevTestbed) -> *mut c_char;
    pub fn umockdev_testbed_set_attribute(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char, value: *const c_char);
    pub fn umockdev_testbed_set_attribute_binary(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char, value: *mut u8, value_length1: c_int);
    pub fn umockdev_testbed_set_attribute_int(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char, value: c_int);
    pub fn umockdev_testbed_set_attribute_hex(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char, value: c_uint);
    pub fn umockdev_testbed_set_attribute_link(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char, value: *const c_char);
    pub fn umockdev_testbed_get_property(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char) -> *mut c_char;
    pub fn umockdev_testbed_set_property(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char, value: *const c_char);
    pub fn umockdev_testbed_set_property_int(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char, value: c_int);
    pub fn umockdev_testbed_set_property_hex(self_: *mut UMockdevTestbed, devpath: *const c_char, name: *const c_char, value: c_uint);
    pub fn umockdev_testbed_add_devicev(self_: *mut UMockdevTestbed, subsystem: *const c_char, name: *const c_char, parent: *const c_char, attributes: *mut *mut c_char, properties: *mut *mut c_char) -> *mut c_char;
    pub fn umockdev_testbed_add_device(self_: *mut UMockdevTestbed, subsystem: *const c_char, name: *const c_char, parent: *const c_char, ...) -> *mut c_char;
    pub fn umockdev_testbed_remove_device(self_: *mut UMockdevTestbed, syspath: *const c_char);
    pub fn umockdev_testbed_add_from_string(self_: *mut UMockdevTestbed, data: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_add_from_file(self_: *mut UMockdevTestbed, path: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_uevent(self_: *mut UMockdevTestbed, devpath: *const c_char, action: *const c_char);
    pub fn umockdev_testbed_attach_ioctl(self_: *mut UMockdevTestbed, dev: *const c_char, handler: *mut UMockdevIoctlBase, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_detach_ioctl(self_: *mut UMockdevTestbed, dev: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_load_ioctl(self_: *mut UMockdevTestbed, dev: *const c_char, recordfile: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_load_pcap(self_: *mut UMockdevTestbed, sysfs: *const c_char, recordfile: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_load_script(self_: *mut UMockdevTestbed, dev: *const c_char, recordfile: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_load_socket_script(self_: *mut UMockdevTestbed, path: *const c_char, type_: c_int, recordfile: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_load_evemu_events(self_: *mut UMockdevTestbed, dev: *const c_char, eventsfile: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn umockdev_testbed_disable(self_: *mut UMockdevTestbed);
    pub fn umockdev_testbed_enable(self_: *mut UMockdevTestbed);
    pub fn umockdev_testbed_clear(self_: *mut UMockdevTestbed);
    pub fn umockdev_testbed_get_dev_fd(self_: *mut UMockdevTestbed, devnode: *const c_char) -> c_int;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn umockdev_in_mock_environment() -> gboolean;

}
