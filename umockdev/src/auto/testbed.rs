// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,IoctlBase};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "UMockdevTestbed")]
    pub struct Testbed(Object<ffi::UMockdevTestbed, ffi::UMockdevTestbedClass>);

    match fn {
        type_ => || ffi::umockdev_testbed_get_type(),
    }
}

impl Testbed {
        pub const NONE: Option<&'static Testbed> = None;
    

    #[doc(alias = "umockdev_testbed_new")]
    pub fn new() -> Testbed {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::umockdev_testbed_new())
        }
    }
}

impl Default for Testbed {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::Testbed>> Sealed for T {}
}

pub trait TestbedExt: IsA<Testbed> + sealed::Sealed + 'static {
    #[doc(alias = "umockdev_testbed_get_root_dir")]
    #[doc(alias = "get_root_dir")]
    fn root_dir(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::umockdev_testbed_get_root_dir(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "umockdev_testbed_get_sys_dir")]
    #[doc(alias = "get_sys_dir")]
    fn sys_dir(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::umockdev_testbed_get_sys_dir(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "umockdev_testbed_set_attribute")]
    fn set_attribute(&self, devpath: &str, name: &str, value: &str) {
        unsafe {
            ffi::umockdev_testbed_set_attribute(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_testbed_set_attribute_binary")]
    fn set_attribute_binary(&self, devpath: &str, name: &str, value: &[u8]) {
        let value_length1 = value.len() as _;
        unsafe {
            ffi::umockdev_testbed_set_attribute_binary(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0, value.to_glib_none().0, value_length1);
        }
    }

    #[doc(alias = "umockdev_testbed_set_attribute_int")]
    fn set_attribute_int(&self, devpath: &str, name: &str, value: i32) {
        unsafe {
            ffi::umockdev_testbed_set_attribute_int(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0, value);
        }
    }

    #[doc(alias = "umockdev_testbed_set_attribute_hex")]
    fn set_attribute_hex(&self, devpath: &str, name: &str, value: u32) {
        unsafe {
            ffi::umockdev_testbed_set_attribute_hex(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0, value);
        }
    }

    #[doc(alias = "umockdev_testbed_set_attribute_link")]
    fn set_attribute_link(&self, devpath: &str, name: &str, value: &str) {
        unsafe {
            ffi::umockdev_testbed_set_attribute_link(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_testbed_get_property")]
    #[doc(alias = "get_property")]
    fn property(&self, devpath: &str, name: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::umockdev_testbed_get_property(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "umockdev_testbed_set_property")]
    fn set_property(&self, devpath: &str, name: &str, value: &str) {
        unsafe {
            ffi::umockdev_testbed_set_property(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_testbed_set_property_int")]
    fn set_property_int(&self, devpath: &str, name: &str, value: i32) {
        unsafe {
            ffi::umockdev_testbed_set_property_int(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0, value);
        }
    }

    #[doc(alias = "umockdev_testbed_set_property_hex")]
    fn set_property_hex(&self, devpath: &str, name: &str, value: u32) {
        unsafe {
            ffi::umockdev_testbed_set_property_hex(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, name.to_glib_none().0, value);
        }
    }

    #[doc(alias = "umockdev_testbed_add_devicev")]
    fn add_devicev(&self, subsystem: &str, name: &str, parent: Option<&str>, attributes: &[&str], properties: &[&str]) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::umockdev_testbed_add_devicev(self.as_ref().to_glib_none().0, subsystem.to_glib_none().0, name.to_glib_none().0, parent.to_glib_none().0, attributes.to_glib_none().0, properties.to_glib_none().0))
        }
    }

    //#[doc(alias = "umockdev_testbed_add_device")]
    //fn add_device(&self, subsystem: &str, name: &str, parent: Option<&str>, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Option<glib::GString> {
    //    unsafe { TODO: call ffi:umockdev_testbed_add_device() }
    //}

    #[doc(alias = "umockdev_testbed_remove_device")]
    fn remove_device(&self, syspath: &str) {
        unsafe {
            ffi::umockdev_testbed_remove_device(self.as_ref().to_glib_none().0, syspath.to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_testbed_add_from_string")]
    fn add_from_string(&self, data: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_add_from_string(self.as_ref().to_glib_none().0, data.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_add_from_file")]
    fn add_from_file(&self, path: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_add_from_file(self.as_ref().to_glib_none().0, path.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_uevent")]
    fn uevent(&self, devpath: &str, action: &str) {
        unsafe {
            ffi::umockdev_testbed_uevent(self.as_ref().to_glib_none().0, devpath.to_glib_none().0, action.to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_testbed_attach_ioctl")]
    fn attach_ioctl(&self, dev: &str, handler: &impl IsA<IoctlBase>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_attach_ioctl(self.as_ref().to_glib_none().0, dev.to_glib_none().0, handler.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_detach_ioctl")]
    fn detach_ioctl(&self, dev: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_detach_ioctl(self.as_ref().to_glib_none().0, dev.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_load_ioctl")]
    fn load_ioctl(&self, dev: Option<&str>, recordfile: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_load_ioctl(self.as_ref().to_glib_none().0, dev.to_glib_none().0, recordfile.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_load_pcap")]
    fn load_pcap(&self, sysfs: &str, recordfile: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_load_pcap(self.as_ref().to_glib_none().0, sysfs.to_glib_none().0, recordfile.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_load_script")]
    fn load_script(&self, dev: Option<&str>, recordfile: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_load_script(self.as_ref().to_glib_none().0, dev.to_glib_none().0, recordfile.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_load_socket_script")]
    fn load_socket_script(&self, path: &str, type_: i32, recordfile: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_load_socket_script(self.as_ref().to_glib_none().0, path.to_glib_none().0, type_, recordfile.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_load_evemu_events")]
    fn load_evemu_events(&self, dev: Option<&str>, eventsfile: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_testbed_load_evemu_events(self.as_ref().to_glib_none().0, dev.to_glib_none().0, eventsfile.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_testbed_disable")]
    fn disable(&self) {
        unsafe {
            ffi::umockdev_testbed_disable(self.as_ref().to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_testbed_enable")]
    fn enable(&self) {
        unsafe {
            ffi::umockdev_testbed_enable(self.as_ref().to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_testbed_clear")]
    fn clear(&self) {
        unsafe {
            ffi::umockdev_testbed_clear(self.as_ref().to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_testbed_get_dev_fd")]
    #[doc(alias = "get_dev_fd")]
    fn dev_fd(&self, devnode: &str) -> i32 {
        unsafe {
            ffi::umockdev_testbed_get_dev_fd(self.as_ref().to_glib_none().0, devnode.to_glib_none().0)
        }
    }
}

impl<O: IsA<Testbed>> TestbedExt for O {}
