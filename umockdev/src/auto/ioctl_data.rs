// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{prelude::*,translate::*};

glib::wrapper! {
    #[doc(alias = "UMockdevIoctlData")]
    pub struct IoctlData(Object<ffi::UMockdevIoctlData, ffi::UMockdevIoctlDataClass>);

    match fn {
        type_ => || ffi::umockdev_ioctl_data_get_type(),
    }
}

impl IoctlData {
        pub const NONE: Option<&'static IoctlData> = None;
    
}

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::IoctlData>> Sealed for T {}
}

pub trait IoctlDataExt: IsA<IoctlData> + sealed::Sealed + 'static {
    #[doc(alias = "umockdev_ioctl_data_ref")]
#[must_use]
    fn compat_ref(&self) -> Option<IoctlData> {
        unsafe {
            from_glib_full(ffi::umockdev_ioctl_data_ref(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "umockdev_ioctl_data_unref")]
    fn compat_unref(&self) {
        unsafe {
            ffi::umockdev_ioctl_data_unref(self.as_ref().to_glib_none().0);
        }
    }

    #[doc(alias = "umockdev_ioctl_data_resolve")]
    fn resolve(&self, offset: usize, len: usize) -> Result<Option<IoctlData>, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::umockdev_ioctl_data_resolve(self.as_ref().to_glib_none().0, offset, len, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_ioctl_data_set_ptr")]
    fn set_ptr(&self, offset: usize, child: &impl IsA<IoctlData>) -> bool {
        unsafe {
            from_glib(ffi::umockdev_ioctl_data_set_ptr(self.as_ref().to_glib_none().0, offset, child.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "umockdev_ioctl_data_reload")]
    fn reload(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::umockdev_ioctl_data_reload(self.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    #[doc(alias = "umockdev_ioctl_data_update")]
    fn update(&self, offset: usize, new_data: &[u8]) {
        let new_data_length1 = new_data.len() as _;
        unsafe {
            ffi::umockdev_ioctl_data_update(self.as_ref().to_glib_none().0, offset, new_data.to_glib_none().0, new_data_length1);
        }
    }

    #[doc(alias = "umockdev_ioctl_data_retrieve")]
    fn retrieve(&self) -> Vec<u8> {
        unsafe {
            let mut read_data = std::ptr::null_mut();
            let mut read_data_length1 = std::mem::MaybeUninit::uninit();
            ffi::umockdev_ioctl_data_retrieve(self.as_ref().to_glib_none().0, &mut read_data, read_data_length1.as_mut_ptr());
            FromGlibContainer::from_glib_full_num(read_data, read_data_length1.assume_init() as _)
        }
    }
}

impl<O: IsA<IoctlData>> IoctlDataExt for O {}
